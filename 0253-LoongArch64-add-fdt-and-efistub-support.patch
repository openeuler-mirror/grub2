From f535f02854e070c6b17a0b3006e6cfa750fbd913 Mon Sep 17 00:00:00 2001
From: yangqiming <yangqiming@loongson.cn>
Date: Thu, 1 Sep 2022 11:21:53 +0800
Subject: [PATCH] LoongArch64 add fdt and efistub support


diff --git a/gentpl.py b/gentpl.py
index 60a8b0d..d23f263 100644
--- a/gentpl.py
+++ b/gentpl.py
@@ -81,7 +81,7 @@ GROUPS["terminfomodule"]   = GRUB_PLATFORMS[:];
 for i in GROUPS["terminfoinkernel"]: GROUPS["terminfomodule"].remove(i)
 
 # Flattened Device Trees (FDT)
-GROUPS["fdt"] = [ "arm64_efi", "arm_uboot", "arm_efi", "riscv32_efi", "riscv64_efi" ]
+GROUPS["fdt"] = [ "arm64_efi", "arm_uboot", "arm_efi", "riscv32_efi", "riscv64_efi", "loongarch64_efi"]
 
 # Needs software helpers for division
 # Must match GRUB_DIVISION_IN_SOFTWARE in misc.h
diff --git a/grub-core/Makefile.am b/grub-core/Makefile.am
index 81566da..6582f16 100644
--- a/grub-core/Makefile.am
+++ b/grub-core/Makefile.am
@@ -244,7 +244,6 @@ if COND_loongarch64_efi
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/efi/efi.h
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/efi/disk.h
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/acpi.h
-KERNEL_HEADER_FILES += $(top_builddir)/include/grub/machine/loongson.h
 endif
 
 if COND_powerpc_ieee1275
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index ee3c56f..ebadbe5 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -117,13 +117,13 @@ kernel = {
   i386_coreboot_startup = kern/i386/coreboot/startup.S;
   i386_multiboot_startup = kern/i386/coreboot/startup.S;
   mips_startup = kern/mips/startup.S;
-  loongarch64_efi_startup = kern/loongarch64/efi/startup.S;
   sparc64_ieee1275_startup = kern/sparc64/ieee1275/crt0.S;
   powerpc_ieee1275_startup = kern/powerpc/ieee1275/startup.S;
   arm_uboot_startup = kern/arm/startup.S;
   arm_coreboot_startup = kern/arm/startup.S;
   arm_efi_startup = kern/arm/efi/startup.S;
   arm64_efi_startup = kern/arm64/efi/startup.S;
+  loongarch64_efi_startup = kern/loongarch64/efi/startup.S;
   riscv32_efi_startup = kern/riscv/efi/startup.S;
   riscv64_efi_startup = kern/riscv/efi/startup.S;
 
@@ -268,6 +268,9 @@ kernel = {
   arm64_efi = kern/arm64/efi/init.c;
   arm64_efi = kern/efi/fdt.c;
 
+  loongarch64_efi = kern/loongarch64/efi/init.c;
+  loongarch64_efi = kern/efi/fdt.c;
+
   riscv32_efi = kern/riscv/efi/init.c;
   riscv32_efi = kern/efi/fdt.c;
 
@@ -328,8 +331,6 @@ kernel = {
   loongarch64 = kern/loongarch64/dl.c;
   loongarch64 = kern/loongarch64/cache.S;
   loongarch64 = kern/generic/rtc_get_time_ms.c;
-  loongarch64_efi = kern/loongarch64/efi/init.c;
-  loongarch64_efi = lib/loongarch64/efi/loongson.c;
 
   powerpc_ieee1275 = kern/powerpc/cache.S;
   powerpc_ieee1275 = kern/powerpc/dl.c;
@@ -1824,6 +1825,8 @@ module = {
   i386_xen_pvh = lib/i386/pc/vesa_modes_table.c;
   mips = loader/mips/linux.c;
   loongarch64 = loader/loongarch64/linux.c;
+  loongarch64 = loader/loongarch64/linux-elf.c;
+  loongarch64 = loader/loongarch64/linux-efi.c;
   powerpc_ieee1275 = loader/powerpc/ieee1275/linux.c;
   sparc64_ieee1275 = loader/sparc64/ieee1275/linux.c;
   ia64_efi = loader/ia64/efi/linux.c;
diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
index 94d9552..a8db638 100644
--- a/grub-core/kern/efi/mm.c
+++ b/grub-core/kern/efi/mm.c
@@ -713,7 +713,8 @@ grub_efi_mm_init (void)
 		       2 * BYTES_TO_PAGES (MEMORY_MAP_SIZE));
 }
 
-#if defined (__aarch64__) || defined (__arm__) || defined (__riscv)
+#if defined (__aarch64__) || defined (__arm__) || defined (__riscv) \
+|| defined (__loongarch__)
 grub_err_t
 grub_efi_get_ram_base(grub_addr_t *base_addr)
 {
@@ -732,9 +733,15 @@ grub_efi_get_ram_base(grub_addr_t *base_addr)
   if (ret < 1)
     return GRUB_ERR_BUG;
 
+#ifdef GRUB_CPU_LOONGARCH64
+  for (desc = memory_map, *base_addr = grub_efi_max_usable_address();
+       (grub_addr_t) desc < ((grub_addr_t) memory_map + memory_map_size);
+       desc = NEXT_MEMORY_DESCRIPTOR (desc, desc_size))
+#else
   for (desc = memory_map, *base_addr = GRUB_EFI_MAX_USABLE_ADDRESS;
        (grub_addr_t) desc < ((grub_addr_t) memory_map + memory_map_size);
        desc = NEXT_MEMORY_DESCRIPTOR (desc, desc_size))
+#endif
     {
       if (desc->type == GRUB_EFI_CONVENTIONAL_MEMORY &&
           (desc->attribute & GRUB_EFI_MEMORY_WB))
diff --git a/grub-core/kern/loongarch64/efi/init.c b/grub-core/kern/loongarch64/efi/init.c
index b21d4f1..1cf0221 100644
--- a/grub-core/kern/loongarch64/efi/init.c
+++ b/grub-core/kern/loongarch64/efi/init.c
@@ -1,4 +1,3 @@
-/* init.c - initialize an arm-based EFI system */
 /*
  *  GRUB  --  GRand Unified Bootloader
  *  Copyright (C) 2013 Free Software Foundation, Inc.
@@ -24,7 +23,6 @@
 #include <grub/cpu/time.h>
 #include <grub/efi/efi.h>
 #include <grub/loader.h>
-#include <grub/machine/loongson.h>
 
 static grub_uint64_t tmr;
 static grub_efi_event_t tmr_evt;
@@ -42,15 +40,13 @@ grub_loongson_increment_timer (grub_efi_event_t event __attribute__ ((unused)),
   tmr += 10;
 }
 
-
-
 void
 grub_machine_init (void)
 {
   grub_efi_boot_services_t *b;
 
   grub_efi_init ();
-  
+
   b = grub_efi_system_table->boot_services;
   efi_call_5 (b->create_event, GRUB_EFI_EVT_TIMER | GRUB_EFI_EVT_NOTIFY_SIGNAL,
               GRUB_EFI_TPL_CALLBACK, grub_loongson_increment_timer, NULL, &tmr_evt);
diff --git a/grub-core/lib/loongarch64/efi/loongson.c b/grub-core/lib/loongarch64/efi/loongson.c
deleted file mode 100644
index 3c6c322..0000000
--- a/grub-core/lib/loongarch64/efi/loongson.c
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2017 Free Software Foundation, Inc.
- *
- *  GRUB is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  GRUB is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <grub/mm.h>
-#include <grub/cache.h>
-#include <grub/efi/efi.h>
-#include <grub/cpu/efi/memory.h>
-#include <grub/cpu/memory.h>
-#include <grub/machine/loongson.h>
-
-int
-grub_efi_get_bpi_version (const char *str)
-{
-  unsigned long version = GRUB_EFI_BPI_VER_NONE;
-
-  version = grub_strtoul (str + 4, 0, 0);
-
-  return version;
-}
-
-void *
-grub_efi_loongson_get_boot_params (void)
-{
-  static void * boot_params = NULL;
-  grub_efi_configuration_table_t *tables;
-  grub_efi_guid_t loongson_bpi_guid = GRUB_EFI_LOONGSON_BPI_TABLE_GUID;
-  unsigned int i;
-
-  if (boot_params)
-    return boot_params;
-
-  /* Look for Loongson boot params interface in UEFI config tables. */
-  tables = grub_efi_system_table->configuration_table;
-
-  for (i = 0; i < grub_efi_system_table->num_table_entries; i++)
-    if (grub_memcmp (&tables[i].vendor_guid, &loongson_bpi_guid, sizeof (loongson_bpi_guid)) == 0)
-      {
-        boot_params= tables[i].vendor_table;
-        grub_dprintf ("loongson", "found registered BPI @ %p\n", boot_params);
-        break;
-      }
-  return boot_params;
-}
-
-grub_uint8_t
-grub_efi_loongson_calculatesum8 (const grub_uint8_t *buffer, grub_efi_uintn_t length)
-{
-  grub_uint8_t sum;
-  grub_efi_uintn_t count;
-
-  for (sum = 0, count = 0; count < length; count++)
-  {
-    sum = (grub_uint8_t) (sum + *(buffer + count));
-  }
-  return sum;
-}
-
-grub_uint8_t
-grub_efi_loongson_grub_calculatechecksum8 (const grub_uint8_t *buffer, grub_efi_uintn_t length)
-{
-  grub_uint8_t checksum;
-
-  checksum = grub_efi_loongson_calculatesum8(buffer, length);
-
-  return (grub_uint8_t) (0x100 - checksum);
-}
-
-
-grub_uint32_t
-grub_efi_loongson_memmap_v1_sort(struct memmap_v1 array[], grub_uint32_t length,
-		mem_map_v1 * bpmem, grub_uint32_t index, grub_uint32_t memtype)
-{
-  grub_uint64_t tempmemsize = 0;
-  grub_uint32_t j = 0;
-  grub_uint32_t t = 0;
-
-  for(j = 0; j < length;)
-  {
-    tempmemsize = array[j].memsize;
-    for(t = j + 1; t < length; t++)
-    {
-      if(array[j].memstart + tempmemsize == array[t].memstart)
-      {
-        tempmemsize += array[t].memsize;
-      }
-      else
-      {
-        break;
-      }
-   }
-   bpmem->map[index].memtype = memtype;
-   bpmem->map[index].memstart = array[j].memstart;
-   bpmem->map[index].memsize = tempmemsize;
-   grub_dprintf("loongson", "v1 map[%d]:type %x, start 0x%llx, end 0x%llx\n",
-		   index,
-		   bpmem->map[index].memtype,
-		   bpmem->map[index].memstart,
-		   bpmem->map[index].memstart+ bpmem->map[index].memsize
-	       );
-   j = t;
-   index++;
-  }
-  return index;
-}
-
-grub_uint32_t
-grub_efi_loongson_memmap_v3_sort(struct memmap_v3 array[], grub_uint32_t length,
-		mem_map_v3 * bpmem, grub_uint32_t index, grub_uint32_t memtype)
-{
-  grub_uint64_t tempmemsize = 0;
-  grub_uint32_t j = 0;
-  grub_uint32_t t = 0;
-
-  for(j = 0; j < length;)
-  {
-    tempmemsize = array[j].memsize;
-    for(t = j + 1; t < length; t++)
-    {
-      if(array[j].memstart + tempmemsize == array[t].memstart)
-      {
-        tempmemsize += array[t].memsize;
-      }
-      else
-      {
-        break;
-      }
-   }
-   bpmem->map[index].memtype = memtype;
-   bpmem->map[index].memstart = array[j].memstart;
-   bpmem->map[index].memsize = tempmemsize;
-   bpmem->map[index].attr = array[j].attr;
-   grub_dprintf("loongson", "v3 map[%d]:type %x, start 0x%llx, end 0x%llx, attr:0x%llx\n",
-		   index,
-		   bpmem->map[index].memtype,
-		   bpmem->map[index].memstart,
-		   bpmem->map[index].memstart+ bpmem->map[index].memsize,
-		   bpmem->map[index].attr
-	       );
-   j = t;
-   index++;
-  }
-  return index;
-}
-
diff --git a/grub-core/lib/loongarch64/setjmp.S b/grub-core/lib/loongarch64/setjmp.S
index 47db814..bb09959 100644
--- a/grub-core/lib/loongarch64/setjmp.S
+++ b/grub-core/lib/loongarch64/setjmp.S
@@ -1,6 +1,6 @@
 /*
  *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2003,2007,2009  Free Software Foundation, Inc.
+ *  Copyright (C) 2021 Free Software Foundation, Inc.
  *
  *  GRUB is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -16,9 +16,7 @@
  *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <grub/symbol.h>
 #include <grub/dl.h>
-#include <grub/loongarch64/asm.h>
 
 	.file	"setjmp.S"
 
@@ -27,48 +25,44 @@ GRUB_MOD_LICENSE "GPLv3+"
 	.text
 
 /*
- * int grub_setjmp (grub_jmp_buf env)
+ * int grub_setjmp (jmp_buf env)
  */
 FUNCTION(grub_setjmp)
-	GRUB_ASM_REG_S $s0, $a0,0
-	GRUB_ASM_REG_S $s1, $a0,8
-	GRUB_ASM_REG_S $s2, $a0,16
-	GRUB_ASM_REG_S $s3, $a0,24
-	GRUB_ASM_REG_S $s4, $a0,32
-	GRUB_ASM_REG_S $s5, $a0,40
-	GRUB_ASM_REG_S $s6, $a0,48
-	GRUB_ASM_REG_S $s7, $a0,56
-	GRUB_ASM_REG_S $s8, $a0,64
-	GRUB_ASM_REG_S $fp, $a0,72
-	GRUB_ASM_REG_S $sp, $a0,80
-	GRUB_ASM_REG_S $ra, $a0,88
-	move $v0, $zero
-	move $v1, $zero
-	jr $ra
-	 nop
+	st.d $s0, $a0, 0x0
+	st.d $s1, $a0, 0x8
+	st.d $s2, $a0, 0x10
+	st.d $s3, $a0, 0x18
+	st.d $s4, $a0, 0x20
+	st.d $s5, $a0, 0x28
+	st.d $s6, $a0, 0x30
+	st.d $s7, $a0, 0x38
+	st.d $s8, $a0, 0x40
+	st.d $fp, $a0, 0x48
+	st.d $sp, $a0, 0x50
+	st.d $ra, $a0, 0x58
+
+	move $a0, $zero
+	jr   $ra
+
 /*
- * int grub_longjmp (grub_jmp_buf env, int val)
+ * void grub_longjmp (jmp_buf env, int val)
  */
 FUNCTION(grub_longjmp)
-	GRUB_ASM_REG_L $s0, $a0,0
-	GRUB_ASM_REG_L $s1, $a0,8
-	GRUB_ASM_REG_L $s2, $a0,16
-	GRUB_ASM_REG_L $s3, $a0,24
-	GRUB_ASM_REG_L $s4, $a0,32
-	GRUB_ASM_REG_L $s5, $a0,40
-	GRUB_ASM_REG_L $s6, $a0,48
-	GRUB_ASM_REG_L $s7, $a0,56
-	GRUB_ASM_REG_L $s8, $a0,64
-	GRUB_ASM_REG_L $fp, $a0,72
-	GRUB_ASM_REG_L $sp, $a0,80
-	GRUB_ASM_REG_L $ra, $a0,88
-	addi.w $v0, $zero, 1
-	/* 
-	 * replace: movn $v0, $a1, $a1
-	*/
-	bnez $a1, .ZW0
-	addi.d $v0, $a1, 0
-.ZW0:
-	addi.d	$v1,$zero,0
-	jr $ra
-	 nop
+	ld.d $s0, $a0, 0x0
+	ld.d $s1, $a0, 0x8
+	ld.d $s2, $a0, 0x10
+	ld.d $s3, $a0, 0x18
+	ld.d $s4, $a0, 0x20
+	ld.d $s5, $a0, 0x28
+	ld.d $s6, $a0, 0x30
+	ld.d $s7, $a0, 0x38
+	ld.d $s8, $a0, 0x40
+	ld.d $fp, $a0, 0x48
+	ld.d $sp, $a0, 0x50
+	ld.d $ra, $a0, 0x58
+
+	li.w $a0, 1
+	beqz $a1, .L0
+	move $a0, $a1
+.L0:
+	jr   $ra
diff --git a/grub-core/loader/loongarch64/linux-efi.c b/grub-core/loader/loongarch64/linux-efi.c
new file mode 100644
index 0000000..6f5ff15
--- /dev/null
+++ b/grub-core/loader/loongarch64/linux-efi.c
@@ -0,0 +1,143 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021 Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <grub/linux.h>
+#include <grub/fdt.h>
+#include <grub/efi/efi.h>
+#include <grub/cpu/linux.h>
+#include <grub/efi/memory.h>
+#include <grub/charset.h>
+
+#define GRUB_EFI_PE_MAGIC	0x5A4D
+
+grub_err_t
+finalize_efi_params_linux (struct linux_loongarch64_kernel_params *kernel_params)
+{
+  int node, retval;
+
+  void *fdt;
+
+  fdt = grub_fdt_load (GRUB_EFI_LINUX_FDT_EXTRA_SPACE);
+
+  if (!fdt)
+    goto failure;
+
+  node = grub_fdt_find_subnode (fdt, 0, "chosen");
+  if (node < 0)
+    node = grub_fdt_add_subnode (fdt, 0, "chosen");
+
+  if (node < 1)
+    goto failure;
+
+  /* Set initrd info */
+  if (kernel_params->ramdisk_addr && kernel_params->ramdisk_size)
+    {
+      grub_dprintf ("linux", "Initrd @ %p-%p\n",
+		    (void *) kernel_params->ramdisk_addr,
+		    (void *) (kernel_params->ramdisk_addr + kernel_params->ramdisk_size));
+
+      retval = grub_fdt_set_prop64 (fdt, node, "linux,initrd-start",
+				    kernel_params->ramdisk_addr);
+      if (retval)
+	goto failure;
+      retval = grub_fdt_set_prop64 (fdt, node, "linux,initrd-end",
+				    kernel_params->ramdisk_addr + kernel_params->ramdisk_size);
+      if (retval)
+	goto failure;
+    }
+
+  if (grub_fdt_install() != GRUB_ERR_NONE)
+    goto failure;
+
+  return GRUB_ERR_NONE;
+
+failure:
+  grub_fdt_unload();
+  return grub_error(GRUB_ERR_BAD_OS, "failed to install/update FDT");
+}
+
+grub_err_t
+grub_arch_efi_linux_check_image (struct linux_arch_kernel_header * lh)
+{
+  if ((lh->code0 & 0xffff) == GRUB_EFI_PE_MAGIC)
+	return GRUB_ERR_NONE;
+  else
+	return 1;
+
+  grub_dprintf ("linux", "UEFI stub kernel:\n");
+  grub_dprintf ("linux", "PE/COFF header @ %08x\n", lh->hdr_offset);
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_arch_efi_linux_boot_image (grub_addr_t addr, grub_size_t size, char *args)
+{
+  grub_efi_memory_mapped_device_path_t *mempath;
+  grub_efi_handle_t image_handle;
+  grub_efi_boot_services_t *b;
+  grub_efi_status_t status;
+  grub_efi_loaded_image_t *loaded_image;
+  int len;
+
+  mempath = grub_malloc (2 * sizeof (grub_efi_memory_mapped_device_path_t));
+  if (!mempath)
+    return grub_errno;
+
+  mempath[0].header.type = GRUB_EFI_HARDWARE_DEVICE_PATH_TYPE;
+  mempath[0].header.subtype = GRUB_EFI_MEMORY_MAPPED_DEVICE_PATH_SUBTYPE;
+  mempath[0].header.length = grub_cpu_to_le16_compile_time (sizeof (*mempath));
+  mempath[0].memory_type = GRUB_EFI_LOADER_DATA;
+  mempath[0].start_address = addr;
+  mempath[0].end_address = addr + size;
+
+  mempath[1].header.type = GRUB_EFI_END_DEVICE_PATH_TYPE;
+  mempath[1].header.subtype = GRUB_EFI_END_ENTIRE_DEVICE_PATH_SUBTYPE;
+  mempath[1].header.length = sizeof (grub_efi_device_path_t);
+
+  b = grub_efi_system_table->boot_services;
+  status = b->load_image (0, grub_efi_image_handle,
+			  (grub_efi_device_path_t *) mempath,
+			  (void *) addr, size, &image_handle);
+  if (status != GRUB_EFI_SUCCESS)
+    return grub_error (GRUB_ERR_BAD_OS, "cannot load image");
+
+  grub_dprintf ("linux", "linux command line: '%s'\n", args);
+
+  /* Convert command line to UCS-2 */
+  loaded_image = grub_efi_get_loaded_image (image_handle);
+  loaded_image->load_options_size = len =
+    (grub_strlen (args) + 1) * sizeof (grub_efi_char16_t);
+  loaded_image->load_options =
+    grub_efi_allocate_any_pages (GRUB_EFI_BYTES_TO_PAGES (loaded_image->load_options_size));
+  if (!loaded_image->load_options)
+    return grub_errno;
+
+  loaded_image->load_options_size =
+    2 * grub_utf8_to_utf16 (loaded_image->load_options, len,
+			    (grub_uint8_t *) args, len, NULL);
+
+  grub_dprintf ("linux", "starting image %p\n", image_handle);
+  status = b->start_image (image_handle, 0, NULL);
+
+  /* When successful, not reached */
+  b->unload_image (image_handle);
+  grub_efi_free_pages ((grub_addr_t) loaded_image->load_options,
+		       GRUB_EFI_BYTES_TO_PAGES (loaded_image->load_options_size));
+
+  return grub_errno;
+}
diff --git a/grub-core/loader/loongarch64/linux-elf.c b/grub-core/loader/loongarch64/linux-elf.c
new file mode 100644
index 0000000..99b55e4
--- /dev/null
+++ b/grub-core/loader/loongarch64/linux-elf.c
@@ -0,0 +1,528 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021 Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/cpu/linux.h>
+#include <grub/linux.h>
+#include <grub/fdt.h>
+#include <grub/efi/efi.h>
+#include <grub/elfload.h>
+#include <grub/cpu/relocator.h>
+#include <grub/efi/memory.h>
+
+#define GRUB_ADDRESS_TYPE_SYSRAM	1
+#define GRUB_ADDRESS_TYPE_RESERVED	2
+#define GRUB_ADDRESS_TYPE_ACPI		3
+#define GRUB_ADDRESS_TYPE_NVS		4
+#define GRUB_ADDRESS_TYPE_PMEM		5
+#define GRUB_EFI_LOONGSON_BPI_TABLE_GUID	\
+    { 0x4660f721, 0x2ec5, 0x416a, \
+	{ 0x89, 0x9a, 0x43, 0x18, 0x02, 0x50, 0xa0, 0xc9 } \
+    }
+
+static struct grub_relocator *relocator;
+
+void grub_linux_loongarch_elf_relocator_unload (void)
+{
+  grub_relocator_unload (relocator);
+}
+
+static grub_err_t
+allocate_fdt_and_exit_boot (struct linux_loongarch64_kernel_params *kernel_params)
+{
+  int node, retval;
+  grub_err_t err;
+  unsigned int size;
+  grub_efi_uintn_t mmap_size;
+  grub_efi_uintn_t desc_size;
+  grub_efi_uint32_t desc_version;
+  grub_efi_memory_descriptor_t *mmap_buf;
+
+  size = GRUB_FDT_EMPTY_TREE_SZ + FDT_ADDR_SIZE_EXTRA + GRUB_EFI_LINUX_FDT_EXTRA_SPACE;
+
+  kernel_params->fdt = grub_efi_allocate_any_pages (GRUB_EFI_BYTES_TO_PAGES (size));
+  if (!kernel_params->fdt)
+    return GRUB_ERR_OUT_OF_MEMORY;
+
+  grub_fdt_create_empty_tree (kernel_params->fdt, size);
+  grub_fdt_set_prop32 (kernel_params->fdt, 0, FDT_ADDR_CELLS_STRING, 2);
+  grub_fdt_set_prop32 (kernel_params->fdt, 0, FDT_SIZE_CELLS_STRING, 2);
+
+  node = grub_fdt_find_subnode (kernel_params->fdt, 0, "chosen");
+  if (node < 0)
+    node = grub_fdt_add_subnode (kernel_params->fdt, 0, "chosen");
+  if (node < 1)
+    goto failure;
+
+  grub_dprintf ("loongson", "command_line %s, len %ld\n",
+		  kernel_params->linux_args, grub_strlen(kernel_params->linux_args) + 1);
+  if ((kernel_params->linux_args != NULL) && (grub_strlen(kernel_params->linux_args) > 0)) {
+    retval = grub_fdt_set_prop (kernel_params->fdt, node, "bootargs", kernel_params->linux_args,
+				grub_strlen(kernel_params->linux_args) + 1);
+    if (retval)
+      goto failure;
+  }
+
+  /* Set initrd info */
+  if (kernel_params->ramdisk_addr && kernel_params->ramdisk_size)
+  {
+    grub_dprintf ("linux", "Initrd @ %p-%p\n",
+		    (void *) kernel_params->ramdisk_addr,
+		    (void *) (kernel_params->ramdisk_addr + kernel_params->ramdisk_size));
+
+    retval = grub_fdt_set_prop64 (kernel_params->fdt, node, "linux,initrd-start",
+				    kernel_params->ramdisk_addr);
+    if (retval)
+	  goto failure;
+    retval = grub_fdt_set_prop64 (kernel_params->fdt, node, "linux,initrd-end",
+		                  (void *) (kernel_params->ramdisk_addr + kernel_params->ramdisk_size));
+    if (retval)
+	  goto failure;
+  }
+
+  node = grub_fdt_find_subnode (kernel_params->fdt, 0, "chosen");
+  retval = grub_fdt_set_prop64 (kernel_params->fdt, node, "linux,uefi-system-table",
+		                (grub_uint64_t)grub_efi_system_table);
+  if (retval)
+	goto failure;
+
+  mmap_size = grub_efi_find_mmap_size ();
+  if (! mmap_size)
+    return grub_errno;
+  mmap_buf = grub_efi_allocate_any_pages (GRUB_EFI_BYTES_TO_PAGES (mmap_size));
+  if (! mmap_buf)
+    return grub_error (GRUB_ERR_IO, "cannot allocate memory map");
+  err = grub_efi_finish_boot_services (&mmap_size, mmap_buf, NULL,
+                                         &desc_size, &desc_version);
+  if (err)
+    return err;
+
+  if (!mmap_buf || !mmap_size || !desc_size)
+    return GRUB_ERR_BAD_ARGUMENT;
+
+  retval = grub_fdt_set_prop64 (kernel_params->fdt, node, "linux,uefi-mmap-start",
+		                (grub_uint64_t)mmap_buf);
+  if (retval)
+	goto failure;
+
+  retval = grub_fdt_set_prop32 (kernel_params->fdt, node, "linux,uefi-mmap-size",
+		                mmap_size);
+  if (retval)
+	goto failure;
+
+  retval = grub_fdt_set_prop32 (kernel_params->fdt, node, "linux,uefi-mmap-desc-size",
+		                desc_size);
+  if (retval)
+	goto failure;
+
+  retval = grub_fdt_set_prop32 (kernel_params->fdt, node, "linux,uefi-mmap-desc-ver",
+		                desc_version);
+  if (retval)
+	goto failure;
+
+  return GRUB_ERR_NONE;
+
+failure:
+  if (!kernel_params->fdt) {
+    return GRUB_ERR_BAD_OS;
+  }
+  grub_efi_free_pages ((grub_addr_t) kernel_params->fdt,
+		       GRUB_EFI_BYTES_TO_PAGES (grub_fdt_get_totalsize (kernel_params->fdt)));
+  kernel_params->fdt = NULL;
+  return grub_error(GRUB_ERR_BAD_OS, "failed to install/update FDT");
+}
+
+static void
+grub_linux_loongarch_elf_make_argv (struct linux_loongarch64_kernel_params *kernel_params)
+{
+  static void* linux_args_addr;
+  int size;
+  grub_uint64_t *linux_argv;
+  char *args, *p, *linux_args;
+  int i, argc;
+  grub_err_t err;
+
+  argc = kernel_params->linux_argc;
+  args = kernel_params->linux_args;
+
+  /* new size */
+  p = args;
+  size = (argc + 3 + 1) * sizeof (grub_uint64_t);  /* orig arguments */
+  for (i = 0; i < argc; i++)
+    {
+      size += ALIGN_UP (grub_strlen (p) + 1, 4);
+      p += grub_strlen (p) + 1;
+    }
+
+  if (kernel_params->ramdisk_addr && kernel_params->ramdisk_size)
+  {
+    size += ALIGN_UP (sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"), 4) \
+	  + ALIGN_UP (sizeof ("rd_size=0xXXXXXXXXXXXXXXXX"), 4) \
+	  + ALIGN_UP (sizeof ("initrd=0xXXXXXXXXXXXXXXXX,0xXXXXXXXXXXXXXXXX"),
+		      4);
+  }
+  size = ALIGN_UP (size, 8);
+
+  /* alloc memory */
+  linux_args_addr = grub_linux_loongarch_alloc_virtual_mem_align (size, 8, &err);
+
+  linux_argv = linux_args_addr;
+  linux_args = (char *)(linux_argv + (argc + 1 + 3));
+  p = args;
+  for (i = 0; i < argc; i++)
+    {
+      grub_memcpy (linux_args, p, grub_strlen (p) + 1);
+      *linux_argv = (grub_uint64_t) (grub_addr_t) linux_args;
+      linux_argv++;
+      linux_args += ALIGN_UP (grub_strlen (p) + 1, 4);
+      p += grub_strlen (p) + 1;
+    }
+
+  if (kernel_params->ramdisk_addr && kernel_params->ramdisk_size)
+  {
+    /* rd_start */
+    grub_snprintf (linux_args,
+		 sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"),
+		 "rd_start=0x%lx",
+		 (grub_uint64_t) kernel_params->ramdisk_addr);
+    *linux_argv = (grub_uint64_t) (grub_addr_t) linux_args;
+    linux_argv++;
+    linux_args += ALIGN_UP (sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"), 4);
+    kernel_params->linux_argc++;
+
+    /* rd_size */
+    grub_snprintf (linux_args,
+		 sizeof ("rd_size=0xXXXXXXXXXXXXXXXX"),
+		 "rd_size=0x%lx",
+		 (grub_uint64_t) kernel_params->ramdisk_size);
+    *linux_argv = (grub_uint64_t) (grub_addr_t) linux_args;
+    linux_argv++;
+    linux_args += ALIGN_UP (sizeof ("rd_size=0xXXXXXXXXXXXXXXXX"), 4);
+    kernel_params->linux_argc++;
+
+    /* initrd */
+    grub_snprintf (linux_args,
+		 sizeof ("initrd=0xXXXXXXXXXXXXXXXX,0xXXXXXXXXXXXXXXXX"),
+		 "initrd=0x%lx,0x%lx",
+		 ((grub_uint64_t) kernel_params->ramdisk_addr & 0xffffffff),
+		 (grub_uint64_t) kernel_params->ramdisk_size);
+    *linux_argv = (grub_uint64_t) (grub_addr_t) linux_args;
+    linux_argv++;
+    linux_args += ALIGN_UP (sizeof ("initrd=0xXXXXXXXXXXXXXXXX,0xXXXXXXXXXXXXXXXX"), 4);
+    kernel_params->linux_argc++;
+  }
+
+  /* Reserve space for initrd arguments.  */
+  *linux_argv = 0;
+
+  grub_free (kernel_params->linux_args);
+  kernel_params->linux_argv = (grub_addr_t) linux_args_addr;
+}
+
+grub_err_t
+grub_linux_loongarch_elf_linux_boot_image (struct linux_loongarch64_kernel_params
+					   *kernel_params)
+{
+  struct boot_params_interface *boot_params = NULL;
+  struct grub_relocator64_state state;
+  grub_err_t err;
+
+  /* linux kernel type is ELF */
+  grub_memset (&state, 0, sizeof (state));
+
+  state.jumpreg = 1;
+  state.gpr[1] = kernel_params->kernel_addr;  /* ra */
+  if (grub_linux_loongarch_elf_get_boot_params (&boot_params) == 0)
+    {
+      grub_printf("not find param, is fdt boot\n");
+      if (allocate_fdt_and_exit_boot (kernel_params) != GRUB_ERR_NONE)
+        return grub_errno;
+      state.gpr[4] = 1 << FLAGS_EFI_SUPPORT_BIT;   /* a0 = flag */
+      state.gpr[5] = (grub_uint64_t)kernel_params->fdt; /* a1 = fdt */
+      state.gpr[6] = 0; /* a2 = flag */
+    } else {
+      grub_printf("find param, is bpi boot\n");
+      grub_linux_loongarch_elf_make_argv (kernel_params);
+      state.gpr[4] = kernel_params->linux_argc;   /* a0 = argc */
+      state.gpr[5] = kernel_params->linux_argv; /* a1 = args */
+      state.gpr[6] = (grub_uint64_t) boot_params; /* a2 = envp */
+      err = grub_linux_loongarch_elf_boot_params (boot_params);
+      if (err)
+        return err;
+    }
+
+  /* Boot the ELF kernel */
+  grub_relocator64_boot (relocator, state);
+
+  return GRUB_ERR_NONE;
+}
+
+void*
+grub_linux_loongarch_alloc_virtual_mem_addr (grub_addr_t addr,
+					     grub_size_t size,
+					     grub_err_t *err)
+{
+  relocator = grub_relocator_new ();
+  if (!relocator)
+    return NULL;
+
+  grub_relocator_chunk_t ch;
+  *err = grub_relocator_alloc_chunk_addr (relocator, &ch,
+					 grub_vtop ((void *) addr),
+					 size);
+  if (*err)
+    return NULL;
+  return get_virtual_current_address (ch);
+}
+
+void*
+grub_linux_loongarch_alloc_virtual_mem_align (grub_size_t size,
+					      grub_size_t align,
+					      grub_err_t *err)
+{
+  grub_relocator_chunk_t ch;
+
+  *err = grub_relocator_alloc_chunk_align (relocator, &ch,
+					  0, (0xffffffff - size) + 1,
+					  size, align,
+					  GRUB_RELOCATOR_PREFERENCE_LOW, 0);
+  return get_virtual_current_address (ch);
+}
+
+int
+grub_linux_loongarch_elf_get_boot_params (struct boot_params_interface **boot_params)
+{
+  grub_efi_configuration_table_t *tables;
+  grub_efi_guid_t bpi_guid = GRUB_EFI_LOONGSON_BPI_TABLE_GUID;
+  unsigned int i;
+  int found = 0;
+
+  /* Look for Loongson BPI in UEFI config tables. */
+  tables = grub_efi_system_table->configuration_table;
+
+  for (i = 0; i < grub_efi_system_table->num_table_entries; i++)
+    if (grub_memcmp (&tables[i].vendor_guid, &bpi_guid, sizeof (bpi_guid)) == 0)
+      {
+	*boot_params = tables[i].vendor_table;
+	char *p = (char*) &((*boot_params)->signature);
+	if (grub_strncmp (p, "BPI", 3) == 0)
+	  {
+	    found = 1;
+	    break;
+	  }
+      }
+  return found;
+}
+
+static grub_uint8_t
+grub_kernel_update_checksum (const grub_uint8_t *buffer, grub_efi_uintn_t length)
+{
+  grub_uint8_t sum;
+  grub_efi_uintn_t count;
+
+  for (sum = 0, count = 0; count < length; count++)
+  {
+    sum = (grub_uint8_t) (sum + *(buffer + count));
+  }
+
+  return (grub_uint8_t) (0x100 - sum);
+}
+
+static grub_uint32_t
+grub_efi_loongarch64_memmap_sort (struct memmap array[],
+				  grub_uint32_t length,
+				  struct loongsonlist_mem_map* bpmem,
+				  grub_uint32_t index,
+				  grub_uint32_t memtype)
+{
+  grub_uint64_t tempmemsize = 0;
+  grub_uint32_t j = 0;
+  grub_uint32_t t = 0;
+
+  for(j = 0; j < length;)
+  {
+    tempmemsize = array[j].mem_size;
+    for(t = j + 1; t < length; t++)
+    {
+      if(array[j].mem_start + tempmemsize == array[t].mem_start)
+      {
+        tempmemsize += array[t].mem_size;
+      }
+      else
+      {
+        break;
+      }
+    }
+    bpmem->map[index].mem_type = memtype;
+    bpmem->map[index].mem_start = array[j].mem_start;
+    bpmem->map[index].mem_size = tempmemsize;
+    grub_printf("map[%d]:type %"PRIuGRUB_UINT32_T", start 0x%"
+		PRIxGRUB_UINT64_T", end 0x%"PRIxGRUB_UINT64_T"\n",
+		index,
+		bpmem->map[index].mem_type,
+		bpmem->map[index].mem_start,
+		bpmem->map[index].mem_start+ bpmem->map[index].mem_size
+	       );
+    j = t;
+    index++;
+  }
+  return index;
+}
+
+grub_err_t
+grub_linux_loongarch_elf_boot_params (struct boot_params_interface *boot_params)
+{
+  grub_int8_t checksum = 0;
+  grub_err_t err;
+
+  struct loongsonlist_mem_map *loongson_mem_map = NULL;
+  struct _extention_list_hdr * listpointer = NULL;
+  grub_uint32_t tmp_index = 0;
+  grub_efi_memory_descriptor_t * lsdesc = NULL;
+
+  grub_uint32_t free_index = 0;
+  grub_uint32_t reserve_index = 0;
+  grub_uint32_t acpi_table_index = 0;
+  grub_uint32_t acpi_nvs_index = 0;
+
+  grub_efi_uintn_t mmap_size;
+  grub_efi_uintn_t desc_size;
+  grub_efi_memory_descriptor_t *mmap_buf;
+
+  struct memmap reserve_mem[GRUB_LOONGSON3_BOOT_MEM_MAP_MAX];
+  struct memmap free_mem[GRUB_LOONGSON3_BOOT_MEM_MAP_MAX];
+  struct memmap acpi_table_mem[GRUB_LOONGSON3_BOOT_MEM_MAP_MAX];
+  struct memmap acpi_nvs_mem[GRUB_LOONGSON3_BOOT_MEM_MAP_MAX];
+
+  grub_memset (reserve_mem, 0, sizeof(struct memmap) * GRUB_LOONGSON3_BOOT_MEM_MAP_MAX);
+  grub_memset (free_mem, 0, sizeof(struct memmap) * GRUB_LOONGSON3_BOOT_MEM_MAP_MAX);
+  grub_memset (acpi_table_mem, 0, sizeof(struct memmap) * GRUB_LOONGSON3_BOOT_MEM_MAP_MAX);
+  grub_memset (acpi_nvs_mem, 0, sizeof(struct memmap) * GRUB_LOONGSON3_BOOT_MEM_MAP_MAX);
+
+  /* Check extlist headers */
+  listpointer = boot_params->extlist;
+  for( ;listpointer != NULL; listpointer = listpointer->next)
+    {
+      char *pl= (char *)&(listpointer->signature);
+      if(grub_strncmp(pl, "MEM", 3) == 0)
+        {
+          loongson_mem_map = (struct loongsonlist_mem_map *)listpointer;
+          break;
+        }
+    }
+
+  mmap_size = grub_efi_find_mmap_size ();
+  if (! mmap_size)
+    return grub_errno;
+  mmap_buf = grub_efi_allocate_any_pages (GRUB_EFI_BYTES_TO_PAGES (mmap_size));
+  if (! mmap_buf)
+    return grub_error (GRUB_ERR_IO, "cannot allocate memory map");
+
+  err = grub_efi_finish_boot_services (&mmap_size, mmap_buf, NULL,
+				       &desc_size, NULL);
+  if (err)
+    return err;
+
+  if (!mmap_buf || !mmap_size || !desc_size)
+    return -1;
+
+  /*
+     According to UEFI SPEC,mmap_buf is the accurate Memory Map array \
+     now we can fill platform specific memory structure.
+     */
+  for (lsdesc = mmap_buf; lsdesc < (grub_efi_memory_descriptor_t *)((char *)mmap_buf + mmap_size);
+      lsdesc = (grub_efi_memory_descriptor_t *)((char *)lsdesc + desc_size))
+    {
+      /* System RAM */
+      if((lsdesc->type != GRUB_EFI_ACPI_RECLAIM_MEMORY) && \
+	 (lsdesc->type != GRUB_EFI_ACPI_MEMORY_NVS) && \
+	 (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_DATA) && \
+	 (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_CODE) && \
+	 (lsdesc->type != GRUB_EFI_RESERVED_MEMORY_TYPE) && \
+	 (lsdesc->type != GRUB_EFI_PAL_CODE))
+	{
+	  free_mem[free_index].mem_type = GRUB_ADDRESS_TYPE_SYSRAM;
+	  free_mem[free_index].mem_start = (lsdesc->physical_start) & GRUB_EFI_MAX_PHY_ADDRESS;
+	  free_mem[free_index].mem_size = lsdesc->num_pages * GRUB_EFI_PAGE_SIZE;
+	  free_index++;
+
+	  /*ACPI*/
+	}else if((lsdesc->type == GRUB_EFI_ACPI_RECLAIM_MEMORY)){
+	    acpi_table_mem[acpi_table_index].mem_type = GRUB_ADDRESS_TYPE_ACPI;
+	    acpi_table_mem[acpi_table_index].mem_start = (lsdesc->physical_start) & GRUB_EFI_MAX_PHY_ADDRESS;
+	    acpi_table_mem[acpi_table_index].mem_size = lsdesc->num_pages * GRUB_EFI_PAGE_SIZE;
+	    acpi_table_index++;
+	}else if((lsdesc->type == GRUB_EFI_ACPI_MEMORY_NVS)){
+	    acpi_nvs_mem[acpi_nvs_index].mem_type = GRUB_ADDRESS_TYPE_NVS;
+	    acpi_nvs_mem[acpi_nvs_index].mem_start = (lsdesc->physical_start) & GRUB_EFI_MAX_PHY_ADDRESS;
+	    acpi_nvs_mem[acpi_nvs_index].mem_size = lsdesc->num_pages * GRUB_EFI_PAGE_SIZE;
+	    acpi_nvs_index++;
+
+	/* Reserve */
+	}else{
+	    reserve_mem[reserve_index].mem_type = GRUB_ADDRESS_TYPE_RESERVED;
+	    reserve_mem[reserve_index].mem_start = (lsdesc->physical_start) & GRUB_EFI_MAX_PHY_ADDRESS;
+	    reserve_mem[reserve_index].mem_size = lsdesc->num_pages * GRUB_EFI_PAGE_SIZE;
+	    reserve_index++;
+	}
+    }
+
+  tmp_index = loongson_mem_map->map_count;
+  /*System RAM Sort*/
+  tmp_index = grub_efi_loongarch64_memmap_sort(free_mem,
+						free_index,
+						loongson_mem_map,
+						tmp_index,
+						GRUB_ADDRESS_TYPE_SYSRAM);
+  /*ACPI Sort*/
+  tmp_index = grub_efi_loongarch64_memmap_sort(acpi_table_mem,
+						acpi_table_index,
+						loongson_mem_map,
+						tmp_index,
+						GRUB_ADDRESS_TYPE_ACPI);
+  tmp_index = grub_efi_loongarch64_memmap_sort(acpi_nvs_mem,
+						acpi_nvs_index,
+						loongson_mem_map,
+						tmp_index,
+						GRUB_ADDRESS_TYPE_NVS);
+
+  /*Reserve Sort*/
+  {
+    grub_uint64_t loongarch_addr;
+    asm volatile ("csrrd %0, 0x181" : "=r" (loongarch_addr));
+    if ((loongarch_addr & 0xff00000000000000) == 0x9000000000000000)
+      tmp_index = grub_efi_loongarch64_memmap_sort(reserve_mem,
+						reserve_index,
+						loongson_mem_map,
+						tmp_index,
+						GRUB_ADDRESS_TYPE_RESERVED);
+    else
+      tmp_index = grub_efi_loongarch64_memmap_sort(reserve_mem,
+						reserve_index,
+						loongson_mem_map,
+						tmp_index,
+						GRUB_ADDRESS_TYPE_RESERVED + 1);
+  }
+  loongson_mem_map->map_count = tmp_index;
+  loongson_mem_map->header.checksum = 0;
+
+  checksum = grub_kernel_update_checksum ((grub_uint8_t *) loongson_mem_map,
+					  loongson_mem_map->header.length);
+  loongson_mem_map->header.checksum = checksum;
+
+  return grub_errno;
+}
diff --git a/grub-core/loader/loongarch64/linux.c b/grub-core/loader/loongarch64/linux.c
index e4aaf7b..f29ac88 100644
--- a/grub-core/loader/loongarch64/linux.c
+++ b/grub-core/loader/loongarch64/linux.c
@@ -1,7 +1,6 @@
-/* linux.c - boot Linux */
 /*
  *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2003,2004,2005,2007,2009,2010,2017  Free Software Foundation, Inc.
+ *  Copyright (C) 2021 Free Software Foundation, Inc.
  *
  *  GRUB is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -17,358 +16,41 @@
  *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <grub/efi/api.h>
-#include <grub/efi/efi.h>
-#include <grub/elf.h>
-#include <grub/elfload.h>
 #include <grub/loader.h>
-#include <grub/dl.h>
-#include <grub/mm.h>
 #include <grub/misc.h>
 #include <grub/command.h>
-#include <grub/cpu/relocator.h>
-#include <grub/machine/loongson.h>
-#include <grub/memory.h>
 #include <grub/i18n.h>
 #include <grub/lib/cmdline.h>
 #include <grub/linux.h>
-
+#include <grub/cpu/linux.h>
+#include <grub/efi/memory.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
-#pragma GCC diagnostic ignored "-Wcast-align"
+#define INITRD_MAX_ADDRESS_OFFSET (32ULL * 1024 * 1024 * 1024)
 
-typedef  unsigned long size_t;
+static struct linux_loongarch64_kernel_params kernel_params;
 
+static grub_addr_t phys_addr;
 static grub_dl_t my_mod;
-
 static int loaded;
-
-static grub_uint32_t tmp_index = 0;
-static grub_size_t linux_size;
-
-static struct grub_relocator *relocator;
-static grub_addr_t target_addr, entry_addr;
-static int linux_argc;
-static grub_uint8_t *linux_args_addr;
-static grub_off_t rd_addr_arg_off, rd_size_arg_off;
-static grub_off_t initrd_addr_arg_off;
-static int initrd_loaded = 0;
-
-
-grub_uint32_t free_index = 0;
-grub_uint32_t reserve_index = 0;
-grub_uint32_t acpi_table_index = 0;
-grub_uint32_t acpi_nvs_index = 0;
-
-static inline grub_size_t
-page_align (grub_size_t size)
-{
-  return (size + (1 << 12) - 1) & (~((1 << 12) - 1));
-}
-
-static inline grub_uint64_t
-grub_efi_max_usable_address(void)
-{
-  grub_uint64_t addr;
-  asm volatile ("csrrd %0, 0x181" : "=r" (addr));
-  grub_dprintf("loongson", "max usable addr 0x%llx\n", addr);
-  return addr |= 0xffffffffffUL;
-}
-
-/* Find the optimal number of pages for the memory map. Is it better to
-   move this code to efi/mm.c?  */
-static grub_efi_uintn_t
-find_mmap_size (void)
-{
-  static grub_efi_uintn_t mmap_size = 0;
-
-  if (mmap_size != 0)
-    return mmap_size;
-
-  mmap_size = (1 << 12);
-  while (1)
-    {
-      int ret;
-      grub_efi_memory_descriptor_t *mmap;
-      grub_efi_uintn_t desc_size;
-
-      mmap = grub_malloc (mmap_size);
-      if (! mmap)
-        return 0;
-
-      ret = grub_efi_get_memory_map (&mmap_size, mmap, 0, &desc_size, 0);
-      grub_free (mmap);
-
-      if (ret < 0)
-      {
-        grub_error (GRUB_ERR_IO, "cannot get memory map");
-        return 0;
-      }
-      else if (ret > 0)
-        break;
-
-      mmap_size += (1 << 12);
-    }
-
-
-  /* Increase the size a bit for safety, because GRUB allocates more on
-     later, and EFI itself may allocate more.  */
-  mmap_size += (1 << 12);
-
-  return page_align (mmap_size);
-}
+static int is_bpi_boot;
+static int grub_loongarch_linux_type = GRUB_LOONGARCH_LINUX_BAD;
 
 static grub_err_t
 grub_linux_boot (void)
 {
-  struct grub_relocator64_state state;
-  grub_int8_t checksum = 0;
-  grub_efi_memory_descriptor_t * lsdesc = NULL;
-
-  grub_memset (&state, 0, sizeof (state));
-
-  /* Boot the kernel.  */
-  state.gpr[1] = entry_addr;
-  grub_dprintf("loongson", "entry_addr is %p\n", state.gpr[1]);
-  state.gpr[4] = linux_argc;
-  grub_dprintf("loongson", "linux_argc is %d\n", state.gpr[4]);
-  state.gpr[5] = (grub_addr_t) linux_args_addr;
-  grub_dprintf("loongson", "args_addr is %p\n", state.gpr[5]);
-
-  {
-    grub_efi_uintn_t mmap_size;
-    grub_efi_uintn_t desc_size;
-    grub_efi_uint32_t desc_version;
-    grub_efi_memory_descriptor_t *mmap_buf;
-    grub_err_t err;
-    struct boot_params_interface * boot_params;
-    void * tmp_boot_params = NULL;
-    mem_map_v1 * mem_map_v1_table = NULL;
-    mem_map_v3 * mem_map_v3_table = NULL;
-    int bpi_version = 0;
-
-    struct memmap_v1 reserve_mem_v1[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap_v1 free_mem_v1[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap_v1 acpi_table_mem_v1[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap_v1 acpi_nvs_mem_v1[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap_v3 reserve_mem_v3[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap_v3 free_mem_v3[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap_v3 acpi_table_mem_v3[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap_v3 acpi_nvs_mem_v3[GRUB_EFI_LOONGSON_MMAP_MAX];
-
-    grub_memset(reserve_mem_v1, 0, sizeof(struct memmap_v1) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(free_mem_v1, 0, sizeof(struct memmap_v1) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(acpi_table_mem_v1, 0, sizeof(struct memmap_v1) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(acpi_nvs_mem_v1, 0, sizeof(struct memmap_v1) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(reserve_mem_v3, 0, sizeof(struct memmap_v3) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(free_mem_v3, 0, sizeof(struct memmap_v3) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(acpi_table_mem_v3, 0, sizeof(struct memmap_v3) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(acpi_nvs_mem_v3, 0, sizeof(struct memmap_v3) * GRUB_EFI_LOONGSON_MMAP_MAX);
-
-    tmp_boot_params = grub_efi_loongson_get_boot_params();
-    if (tmp_boot_params == NULL)
-    {
-      grub_int8_t signature[8] = {'B','P','I','0','1','0','0','2'};
-      boot_params = grub_efi_allocate_pages_real (grub_efi_max_usable_address(),
-				       page_align (64 * 1024) >> 12, GRUB_EFI_ALLOCATE_MAX_ADDRESS,
-				       GRUB_EFI_RUNTIME_SERVICES_DATA);
-      grub_dprintf("loongson", "create bpi, boot_params is %p\n", boot_params);
-      if (! boot_params)
-        return grub_error (GRUB_ERR_IO, "cannot allocate boot params ");
-
-      memcpy(&boot_params->signature, signature, sizeof(grub_uint64_t));
-      boot_params->extlist_offset = sizeof(*boot_params);
-      boot_params->flags = 1 << FLAGS_EFI_SUPPORT_BIT;
-      boot_params->systemtable = grub_efi_system_table;
-
-      mem_map_v3_table = (mem_map_v3 *)((char *)boot_params + boot_params->extlist_offset);
-      memset(&mem_map_v3_table->header, 0, sizeof(struct _extention_list_hdr));
-      memcpy(&mem_map_v3_table->header.signature, "MEM", sizeof(grub_uint64_t));
-      mem_map_v3_table->header.revision = 0;
-      mem_map_v3_table->header.length = sizeof(*mem_map_v3_table);
-    } else {
-      boot_params = (struct boot_params_interface *)tmp_boot_params;
-
-      ext_list * listpointer = NULL;
-      /* Check extlist headers */
-      listpointer = boot_params->extlist;
-      for( ;listpointer != NULL; listpointer = listpointer->next)
-      {
-        char *pl= (char *)&(listpointer->signature);
-        if(grub_strncmp(pl, "MEM", 3) == 0)
-        {
-          mem_map_v1_table = (mem_map_v1 *)listpointer;
-          break;
-        }
-      }
-    }
-
-    grub_dprintf("loongson", "boot_params is %p\n", boot_params);
-    state.gpr[6] = (grub_uint64_t)boot_params;
-
-    mmap_size = find_mmap_size ();
-    if (! mmap_size)
-      return grub_errno;
-    mmap_buf = grub_efi_allocate_any_pages (page_align (mmap_size) >> 12);
-    if (! mmap_buf)
-      return grub_error (GRUB_ERR_IO, "cannot allocate memory map");
-    err = grub_efi_finish_boot_services (&mmap_size, mmap_buf, NULL,
-                                         &desc_size, &desc_version);
-    if (err)
-      return err;
-
-    if (!mmap_buf || !mmap_size || !desc_size)
-      return -1;
-
-    char *p = (char *)&(boot_params->signature);
-    bpi_version = grub_efi_get_bpi_version(p);
-    grub_dprintf("loongson", "get bpi version:%d\n", bpi_version);
-
-    if (bpi_version <= GRUB_EFI_BPI_VER_V2)
-    {
-      /*
-      According to UEFI SPEC,mmap_buf is the accurate Memory Map array \
-      now we can fill platform specific memory structure.
-      */
-      for(lsdesc = mmap_buf; lsdesc < (grub_efi_memory_descriptor_t *)((char *)mmap_buf + mmap_size);
-            lsdesc = (grub_efi_memory_descriptor_t *)((char *)lsdesc + desc_size))
-      {
-        grub_dprintf("loongson", "type:%d, phy_start:0x%llx, phy_end:0x%llx\n", lsdesc->type,
-          lsdesc->physical_start, lsdesc->physical_start + lsdesc->num_pages*4096);
-
-        /* System RAM */
-        if ((lsdesc->type != GRUB_EFI_ACPI_RECLAIM_MEMORY) && \
-            (lsdesc->type != GRUB_EFI_ACPI_MEMORY_NVS) && \
-            (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_DATA) && \
-            (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_CODE) && \
-            (lsdesc->type != GRUB_EFI_RESERVED_MEMORY_TYPE) && \
-            (lsdesc->type != GRUB_EFI_PAL_CODE))
-        {
-          free_mem_v1[free_index].memtype = GRUB_EFI_LOONGSON_SYSTEM_RAM;
-          free_mem_v1[free_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          free_mem_v1[free_index].memsize = lsdesc->num_pages * 4096;
-          free_index++;
-
-        /*ACPI*/
-        } else if ((lsdesc->type == GRUB_EFI_ACPI_RECLAIM_MEMORY)){
-          acpi_table_mem_v1[acpi_table_index].memtype = GRUB_EFI_LOONGSON_ACPI_TABLE;
-          acpi_table_mem_v1[acpi_table_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          acpi_table_mem_v1[acpi_table_index].memsize = lsdesc->num_pages * 4096;
-          acpi_table_index++;
-        } else if ((lsdesc->type == GRUB_EFI_ACPI_MEMORY_NVS)){
-          acpi_nvs_mem_v1[acpi_nvs_index].memtype = GRUB_EFI_LOONGSON_ACPI_NVS;
-          acpi_nvs_mem_v1[acpi_nvs_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          acpi_nvs_mem_v1[acpi_nvs_index].memsize = lsdesc->num_pages * 4096;
-          acpi_nvs_index++;
-
-        /* Reserve */
-        } else {
-          reserve_mem_v1[reserve_index].memtype = GRUB_EFI_LOONGSON_MEMORY_RESERVED;
-          reserve_mem_v1[reserve_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          reserve_mem_v1[reserve_index].memsize = lsdesc->num_pages * 4096;
-          reserve_index++;
-        }
-      }
-
-      tmp_index = mem_map_v1_table->mapcount;
-      /*System RAM Sort*/
-      tmp_index = grub_efi_loongson_memmap_v1_sort(free_mem_v1, free_index, mem_map_v1_table,
-                          tmp_index, GRUB_EFI_LOONGSON_SYSTEM_RAM);
-      /*ACPI Sort*/
-      tmp_index = grub_efi_loongson_memmap_v1_sort(acpi_table_mem_v1, acpi_table_index,
-                    mem_map_v1_table, tmp_index, GRUB_EFI_LOONGSON_ACPI_TABLE);
-      tmp_index = grub_efi_loongson_memmap_v1_sort(acpi_nvs_mem_v1, acpi_nvs_index,
-                    mem_map_v1_table, tmp_index, GRUB_EFI_LOONGSON_ACPI_NVS);
-      /*Reserve Sort*/
-      grub_uint64_t loongarch_addr;
-      asm volatile ("csrrd %0, 0x181" : "=r" (loongarch_addr));
-      if ((loongarch_addr & 0xff00000000000000) == 0x9000000000000000){
-        tmp_index = grub_efi_loongson_memmap_v1_sort(reserve_mem_v1, reserve_index, mem_map_v1_table,
-                      tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED);
-      } else {
-        tmp_index = grub_efi_loongson_memmap_v1_sort(reserve_mem_v1, reserve_index, mem_map_v1_table,
-                      tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED + 1);
-      }
-
-      mem_map_v1_table->mapcount = tmp_index;
-      mem_map_v1_table->header.checksum = 0;
-
-      checksum = grub_efi_loongson_grub_calculatechecksum8(mem_map_v1_table, mem_map_v1_table->header.length);
-      mem_map_v1_table->header.checksum = checksum;
 
-    } else {
-      /*
-      According to UEFI SPEC,mmap_buf is the accurate Memory Map array \
-      now we can fill platform specific memory structure.
-      */
-      for(lsdesc = mmap_buf; lsdesc < (grub_efi_memory_descriptor_t *)((char *)mmap_buf + mmap_size);
-            lsdesc = (grub_efi_memory_descriptor_t *)((char *)lsdesc + desc_size))
-      {
-        grub_dprintf("loongson", "type:%d, phy_start:0x%llx, phy_end:0x%llx, attribute:0x%llx\n", lsdesc->type,
-          lsdesc->physical_start, lsdesc->physical_start + lsdesc->num_pages*4096, lsdesc->attribute);
-
-        /* System RAM */
-        if ((lsdesc->type != GRUB_EFI_ACPI_RECLAIM_MEMORY) && \
-            (lsdesc->type != GRUB_EFI_ACPI_MEMORY_NVS) && \
-            (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_DATA) && \
-            (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_CODE) && \
-            (lsdesc->type != GRUB_EFI_RESERVED_MEMORY_TYPE) && \
-            (lsdesc->type != GRUB_EFI_PAL_CODE))
-        {
-          free_mem_v3[free_index].memtype = GRUB_EFI_LOONGSON_SYSTEM_RAM;
-          free_mem_v3[free_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          free_mem_v3[free_index].memsize = lsdesc->num_pages * 4096;
-          free_mem_v3[free_index].attr = lsdesc->attribute;
-          free_index++;
-
-        /*ACPI*/
-        } else if ((lsdesc->type == GRUB_EFI_ACPI_RECLAIM_MEMORY)){
-          acpi_table_mem_v3[acpi_table_index].memtype = GRUB_EFI_LOONGSON_ACPI_TABLE;
-          acpi_table_mem_v3[acpi_table_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          acpi_table_mem_v3[acpi_table_index].memsize = lsdesc->num_pages * 4096;
-          acpi_table_mem_v3[acpi_table_index].attr = lsdesc->attribute;
-          acpi_table_index++;
-        } else if ((lsdesc->type == GRUB_EFI_ACPI_MEMORY_NVS)){
-          acpi_nvs_mem_v3[acpi_nvs_index].memtype = GRUB_EFI_LOONGSON_ACPI_NVS;
-          acpi_nvs_mem_v3[acpi_nvs_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          acpi_nvs_mem_v3[acpi_nvs_index].memsize = lsdesc->num_pages * 4096;
-          acpi_nvs_mem_v3[acpi_nvs_index].attr = lsdesc->attribute;
-          acpi_nvs_index++;
-
-        /* Reserve */
-        } else {
-          reserve_mem_v3[reserve_index].memtype = GRUB_EFI_LOONGSON_MEMORY_RESERVED;
-          reserve_mem_v3[reserve_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          reserve_mem_v3[reserve_index].memsize = lsdesc->num_pages * 4096;
-          reserve_mem_v3[reserve_index].attr = lsdesc->attribute;
-          reserve_index++;
-        }
-      }
-
-      /*System RAM Sort*/
-      tmp_index = grub_efi_loongson_memmap_v3_sort(free_mem_v3, free_index, mem_map_v3_table,
-                          tmp_index, GRUB_EFI_LOONGSON_SYSTEM_RAM);
-      /*ACPI Sort*/
-      tmp_index = grub_efi_loongson_memmap_v3_sort(acpi_table_mem_v3, acpi_table_index,
-                    mem_map_v3_table, tmp_index, GRUB_EFI_LOONGSON_ACPI_TABLE);
-      tmp_index = grub_efi_loongson_memmap_v3_sort(acpi_nvs_mem_v3, acpi_nvs_index,
-                    mem_map_v3_table, tmp_index, GRUB_EFI_LOONGSON_ACPI_NVS);
-      /*Reserve Sort*/
-      tmp_index = grub_efi_loongson_memmap_v3_sort(reserve_mem_v3, reserve_index,
-                    mem_map_v3_table, tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED);
-
-      mem_map_v3_table->mapcount = tmp_index;
-      mem_map_v3_table->descver = desc_version;
-      mem_map_v3_table->header.checksum = 0;
-
-      checksum = grub_efi_loongson_grub_calculatechecksum8(mem_map_v3_table, mem_map_v3_table->header.length);
-      mem_map_v3_table->header.checksum = checksum;
-    }
+  if (grub_loongarch_linux_type == GRUB_LOONGARCH_LINUX_EFI) {
+      if (finalize_efi_params_linux (&kernel_params) != GRUB_ERR_NONE)
+        return grub_errno;
+      return (grub_arch_efi_linux_boot_image((grub_addr_t) kernel_params.kernel_addr,
+					     kernel_params.kernel_size,
+					     kernel_params.linux_args));
+  }
+  if (grub_loongarch_linux_type == GRUB_LOONGARCH_LINUX_ELF) {
+      return grub_linux_loongarch_elf_linux_boot_image (&kernel_params);
   }
-
-  state.jumpreg = 1;
-  grub_relocator64_boot (relocator, state);
 
   return GRUB_ERR_NONE;
 }
@@ -376,50 +58,34 @@ grub_linux_boot (void)
 static grub_err_t
 grub_linux_unload (void)
 {
-  grub_relocator_unload (relocator);
-  grub_dl_unref (my_mod);
 
-  loaded = 0;
-
-  return GRUB_ERR_NONE;
-}
+  if (grub_loongarch_linux_type == GRUB_LOONGARCH_LINUX_EFI) {
+      if (kernel_params.ramdisk_addr)
+	grub_efi_free_pages ((grub_efi_physical_address_t) kernel_params.ramdisk_addr,
+			     GRUB_EFI_BYTES_TO_PAGES (kernel_params.ramdisk_size));
+      kernel_params.ramdisk_size = 0;
 
-static grub_err_t
-grub_linux_load32 (grub_elf_t elf, const char *filename)
-{
-  Elf32_Addr base;
-  grub_err_t err;
-  grub_uint8_t *playground;
-
-  /* Linux's entry point incorrectly contains a virtual address.  */
-  entry_addr = elf->ehdr.ehdr32.e_entry;
-
-  linux_size = grub_elf32_size (elf, &base, 0);
-  if (linux_size == 0)
-    return grub_errno;
-  target_addr = base;
-  linux_size = ALIGN_UP (base + linux_size - base, 8);
-
-  relocator = grub_relocator_new ();
-  if (!relocator)
-    return grub_errno;
+      if (kernel_params.kernel_addr)
+	grub_efi_free_pages ((grub_addr_t) kernel_params.kernel_addr,
+			     GRUB_EFI_BYTES_TO_PAGES (kernel_params.kernel_size));
+      kernel_params.kernel_addr = 0;
+  }
 
-  {
-    grub_relocator_chunk_t ch;
-    err = grub_relocator_alloc_chunk_addr (relocator, &ch,
-					   grub_vtop ((void *) target_addr),
-					   linux_size);
-    if (err)
-      return err;
-    playground = get_virtual_current_address (ch);
+  if (grub_loongarch_linux_type == GRUB_LOONGARCH_LINUX_ELF) {
+      grub_free (kernel_params.linux_args);
+      kernel_params.linux_args = 0;
+      grub_linux_loongarch_elf_relocator_unload ();
   }
 
-  /* Now load the segments into the area we claimed.  */
-  return grub_elf32_load (elf, filename, playground - base, GRUB_ELF_LOAD_FLAGS_NONE, 0, 0);
+  grub_dl_unref (my_mod);
+  loaded = 0;
+  grub_loongarch_linux_type = GRUB_LOONGARCH_LINUX_BAD;
+
+  return GRUB_ERR_NONE;
 }
 
-static grub_err_t
-grub_linux_load64 (grub_elf_t elf, const char *filename)
+grub_err_t
+grub_linux_loongarch_elf_load_kernel (grub_elf_t elf, const char *filename)
 {
   Elf64_Addr base;
   grub_err_t err;
@@ -428,16 +94,14 @@ grub_linux_load64 (grub_elf_t elf, const char *filename)
   int flag;
 
   /* Linux's entry point incorrectly contains a virtual address.  */
-  entry_addr = elf->ehdr.ehdr64.e_entry;
-  grub_dprintf("loongson", "entry address = %p\n", entry_addr);
-
-  linux_size = grub_elf64_size (elf, &base, 0);
-  grub_dprintf("loongson", "base = %p\n", base);
+  kernel_params.kernel_addr = elf->ehdr.ehdr64.e_entry;
+  kernel_params.kernel_size = grub_elf64_size (elf, &base, 0);
 
-  if (linux_size == 0)
+  if (kernel_params.kernel_size == 0)
     return grub_errno;
-  target_addr = base;
-  linux_size = ALIGN_UP (base + linux_size - base, 8);
+
+  phys_addr = base;
+  kernel_params.kernel_size = ALIGN_UP (base + kernel_params.kernel_size - base, 8);
 
   asm volatile ("csrrd %0, 0x181" : "=r" (addr));
   if (addr & 0x1) {
@@ -445,209 +109,274 @@ grub_linux_load64 (grub_elf_t elf, const char *filename)
   } else {
     flag = GRUB_ELF_LOAD_FLAGS_30BITS;
     base &= ~ELF64_LOADMASK;
-    entry_addr &= ~ELF64_LOADMASK;
+    kernel_params.kernel_addr &= ~ELF64_LOADMASK;
   }
 
-  relocator = grub_relocator_new ();
-  if (!relocator)
-    return grub_errno;
-
-  {
-    grub_relocator_chunk_t ch;
-    err = grub_relocator_alloc_chunk_addr (relocator, &ch,
-					   grub_vtop ((void *) target_addr),
-					   linux_size);
-    if (err)
-      return err;
-    playground = get_virtual_current_address (ch);
-  }
+  playground = grub_linux_loongarch_alloc_virtual_mem_addr (phys_addr,
+							    kernel_params.kernel_size,
+							    &err);
+  if (playground == NULL)
+    return err;
 
   /* Now load the segments into the area we claimed.  */
-  return grub_elf64_load (elf, filename, playground - base, flag, 0, 0);
+  return grub_elf64_load (elf, filename, playground - base,
+			  flag, 0, 0);
 }
 
 static grub_err_t
 grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
 		int argc, char *argv[])
 {
-  grub_elf_t elf = 0;
-  int size;
-  int i;
-  grub_uint64_t *linux_argv;
-  char *linux_args;
+  grub_file_t file = 0;
+  struct linux_arch_kernel_header lh;
+  struct boot_params_interface *boot_params = NULL;
+  grub_elf_t elf = NULL;
   grub_err_t err;
+  grub_size_t cmdline_size;
+  int i;
+
+  grub_dl_ref (my_mod);
+
+  /* Release the previously used memory.  */
+  grub_loader_unset ();
 
   if (argc == 0)
-    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+      goto fail;
+    }
 
-  elf = grub_elf_open (argv[0],GRUB_FILE_TYPE_LINUX_KERNEL);
-  if (! elf)
+  file = grub_file_open (argv[0], GRUB_FILE_TYPE_LINUX_KERNEL);
+  if (!file)
+    goto fail;
+
+  kernel_params.kernel_size = grub_file_size (file);
+  grub_dprintf ("linux", "kernel file size: %" PRIuGRUB_SIZE "\n",
+		kernel_params.kernel_size);
+
+  if (grub_file_read (file, &lh, sizeof (lh)) < (long) sizeof (lh))
     return grub_errno;
 
-  if (elf->ehdr.ehdr32.e_type != ET_EXEC)
+  if (grub_arch_efi_linux_check_image (&lh) == GRUB_ERR_NONE) {
+    grub_loongarch_linux_type = GRUB_LOONGARCH_LINUX_EFI;
+  }
+
+  if (grub_loongarch_linux_type != GRUB_LOONGARCH_LINUX_EFI) {
+    elf = grub_elf_file (file, argv[0]);
+    if (elf != NULL)
     {
-      grub_elf_close (elf);
-      return grub_error (GRUB_ERR_UNKNOWN_OS,
-			 N_("this ELF file is not of the right type"));
+      /* linux kernel type is ELF */
+      grub_loongarch_linux_type = GRUB_LOONGARCH_LINUX_ELF;
+      if (elf->ehdr.ehdr64.e_type != ET_EXEC)
+	{
+	  grub_error (GRUB_ERR_UNKNOWN_OS,
+		      N_("this ELF file is not of the right type"));
+	  goto fail;
+	}
+      if (elf->ehdr.ehdr64.e_machine != EM_LOONGARCH64)
+	{
+	  grub_error (GRUB_ERR_BAD_OS, "invalid magic number");
+	  goto fail;
+	}
+
+      if (grub_elf_is_elf64 (elf))
+	{
+	  err = grub_linux_loongarch_elf_load_kernel (elf, argv[0]);
+	  if (err)
+	    goto fail;
+	} else {
+	    grub_error (GRUB_ERR_BAD_OS, N_("invalid arch-dependent ELF magic"));
+	    goto fail;
+	}
+      grub_dprintf ("linux", "kernel @ %p\n", (void*) elf->ehdr.ehdr64.e_entry);
+    }
+  } else {
+      if (grub_file_seek (file, 0) == (grub_off_t) -1)
+	goto fail;
+
+      if (grub_file_read (file, &lh, sizeof (lh)) < (grub_ssize_t) sizeof (lh))
+	{
+	  if (!grub_errno)
+	    grub_error (GRUB_ERR_BAD_OS, N_("premature end of file %s"),
+			argv[0]);
+	  goto fail;
+	}
+
+      if (grub_arch_efi_linux_check_image (&lh) != GRUB_ERR_NONE)
+	{
+	  goto fail;
+	}
+      /* linux kernel type is EFI */
+      grub_loongarch_linux_type = GRUB_LOONGARCH_LINUX_EFI;
+      kernel_params.kernel_addr = (grub_addr_t) grub_efi_allocate_any_pages (
+				GRUB_EFI_BYTES_TO_PAGES (kernel_params.kernel_size));
+      grub_dprintf ("linux", "kernel numpages: %" PRIuGRUB_SIZE "\n",
+		    GRUB_EFI_BYTES_TO_PAGES (kernel_params.kernel_size));
+      if (!kernel_params.kernel_addr)
+	{
+	  grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
+	  goto fail;
+	}
+
+      grub_file_seek (file, 0);
+      if (grub_file_read (file, (void*) kernel_params.kernel_addr, kernel_params.kernel_size)
+	  < (grub_int64_t) kernel_params.kernel_size)
+	{
+	  if (!grub_errno)
+	    grub_error (GRUB_ERR_BAD_OS, N_("premature end of file %s"), argv[0]);
+	  goto fail;
+	}
+
+      grub_dprintf ("linux", "kernel @ %p\n", (void*) kernel_params.kernel_addr);
     }
 
-  /* Release the previously used memory.  */
-  grub_loader_unset ();
-  loaded = 0;
-
-  /* For arguments.  */
-  linux_argc = argc;
-  /* Main arguments.  */
-  size = (linux_argc) * sizeof (grub_uint64_t);
-  /* Initrd address/size and initrd  */
-  size += 3 * sizeof (grub_uint64_t);
-  /* NULL terminator.  */
-  size += sizeof (grub_uint64_t);
-  /* First argument is always "a0".  */
-  size += ALIGN_UP (sizeof ("a0"), 4);
-  /* Normal arguments.  */
-  for (i = 1; i < argc; i++)
-    size += ALIGN_UP (grub_strlen (argv[i]) + 1, 4);
-
-  /* rd arguments.  */
-  size += ALIGN_UP (sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"), 4);
-  size += ALIGN_UP (sizeof ("rd_size=0xXXXXXXXXXXXXXXXX"), 4);
-  size += ALIGN_UP (sizeof ("initrd=0xXXXXXXXXXXXXXXXX,0xXXXXXXXXXXXXXXXX"), 4);
-
-  size = ALIGN_UP (size, 8);
-
-  if (grub_elf_is_elf32 (elf))
-    err = grub_linux_load32 (elf, argv[0]);
-  else
-  if (grub_elf_is_elf64 (elf))
-    err = grub_linux_load64 (elf, argv[0]);
-  else
-    err = grub_error (GRUB_ERR_BAD_OS, N_("invalid arch-dependent ELF magic"));
+  cmdline_size = grub_loader_cmdline_size (argc, argv) + sizeof (LINUX_IMAGE);
+  kernel_params.linux_argc = argc;
+  kernel_params.linux_args = grub_malloc (cmdline_size);
+  if (!kernel_params.linux_args)
+    {
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
+      goto fail;
+    }
 
-  grub_elf_close (elf);
+  grub_memcpy (kernel_params.linux_args, LINUX_IMAGE, sizeof (LINUX_IMAGE));
 
-  if (err)
-    return err;
+  if (grub_linux_loongarch_elf_get_boot_params (&boot_params) == 1)
+    is_bpi_boot = 1;
+  else
+    is_bpi_boot = 0;
 
-  {
-    grub_relocator_chunk_t ch;
-    err = grub_relocator_alloc_chunk_align (relocator, &ch,
-					    0, (0xffffffff - size) + 1,
-					    size, 8,
-					    GRUB_RELOCATOR_PREFERENCE_HIGH, 0);
-    if (err)
-      return err;
-    linux_args_addr = get_virtual_current_address (ch);
+  if (is_bpi_boot == 0)
+    {
+      err = grub_create_loader_cmdline (argc, argv,
+					(char*) ((grub_addr_t) kernel_params.linux_args + sizeof (LINUX_IMAGE) - 1),
+					cmdline_size,
+					GRUB_VERIFY_KERNEL_CMDLINE);
+      if (err)
+	goto fail;
+    } else {
+      /* save args from linux cmdline */
+      char *p = kernel_params.linux_args;
+
+      p += sizeof (LINUX_IMAGE) - 1;
+      for (i=0; i < argc; i++)
+	{
+	  grub_memcpy (p, argv[i], grub_strlen(argv[i]) + 1);
+	  p += grub_strlen(argv[i]) + 1;
+	}
   }
 
-  linux_argv = (grub_uint64_t *) linux_args_addr;
-  linux_args = (char *) (linux_argv + (linux_argc + 1 + 3));
+  if (grub_errno == GRUB_ERR_NONE)
+    {
+      grub_loader_set (grub_linux_boot, grub_linux_unload, 0);
+      loaded = 1;
+    }
 
-  grub_memcpy (linux_args, "a0", sizeof ("a0"));
-  *linux_argv = (grub_uint64_t) (grub_addr_t) linux_args;
-  linux_argv++;
-  linux_args += ALIGN_UP (sizeof ("a0"), 4);
+fail:
+  if (elf != NULL) {
+      /* grub_elf_close will call grub_file_close() */
+      grub_elf_close (elf);
+  } else {
+      if (file)
+	grub_file_close (file);
+  }
 
-  for (i = 1; i < argc; i++)
+  if (grub_errno != GRUB_ERR_NONE)
     {
-      grub_memcpy (linux_args, argv[i], grub_strlen (argv[i]) + 1);
-      *linux_argv = (grub_uint64_t) (grub_addr_t) linux_args;
-      linux_argv++;
-      linux_args += ALIGN_UP (grub_strlen (argv[i]) + 1, 4);
+      grub_dl_unref (my_mod);
+      loaded = 0;
     }
 
-  /* Reserve space for rd arguments.  */
-  rd_addr_arg_off = (grub_uint8_t *) linux_args - linux_args_addr;
-  linux_args += ALIGN_UP (sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"), 4);
-  *linux_argv = 0;
-  linux_argv++;
+  if (kernel_params.linux_args && !loaded)
+    grub_free (kernel_params.linux_args);
+
+  if (grub_loongarch_linux_type == GRUB_LOONGARCH_LINUX_EFI) {
+      if (kernel_params.kernel_addr && !loaded)
+	grub_efi_free_pages ((grub_addr_t) kernel_params.kernel_addr,
+			     GRUB_EFI_BYTES_TO_PAGES (kernel_params.kernel_size));
+  }
 
-  rd_size_arg_off = (grub_uint8_t *) linux_args - linux_args_addr;
-  linux_args += ALIGN_UP (sizeof ("rd_size=0xXXXXXXXXXXXXXXXX"), 4);
-  *linux_argv = 0;
-  linux_argv++;
+  return grub_errno;
+}
 
-  /* Reserve space for initrd arguments.  */
-  initrd_addr_arg_off = (grub_uint8_t *) linux_args - linux_args_addr;
-  linux_args += ALIGN_UP (sizeof ("initrd=0xXXXXXXXXXXXXXXXX,0xXXXXXXXXXXXXXXXX"), 4);
-  *linux_argv = 0;
-  linux_argv++;
+/*
+ * This function returns a pointer to a legally allocated initrd buffer,
+ * or NULL if unsuccessful
+ */
+static void *
+allocate_initrd_mem (int initrd_pages)
+{
+  grub_addr_t max_addr;
 
-  *linux_argv = 0;
+  if (grub_efi_get_ram_base (&max_addr) != GRUB_ERR_NONE)
+    return NULL;
 
-  grub_loader_set (grub_linux_boot, grub_linux_unload, 0);
-  initrd_loaded = 0;
-  loaded = 1;
-  grub_dl_ref (my_mod);
+  max_addr += INITRD_MAX_ADDRESS_OFFSET - 1;
 
-  return GRUB_ERR_NONE;
+  return grub_efi_allocate_pages_real (max_addr, initrd_pages,
+                                       GRUB_EFI_ALLOCATE_MAX_ADDRESS,
+                                       GRUB_EFI_LOADER_DATA);
 }
 
+
 static grub_err_t
 grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
 		 int argc, char *argv[])
 {
-  grub_size_t size = 0;
-  void *initrd_dest;
-  grub_err_t err;
   struct grub_linux_initrd_context initrd_ctx = { 0, 0, 0 };
+  grub_size_t initrd_size;
+  void *initrd_mem = NULL;
 
   if (argc == 0)
-    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+    {
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+      goto fail;
+    }
 
   if (!loaded)
-    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("you need to load the kernel first"));
-
-  if (initrd_loaded)
-    return grub_error (GRUB_ERR_BAD_ARGUMENT, "only one initrd command can be issued.");
+    {
+      return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("you need to load the kernel first"));
+      goto fail;
+    }
 
   if (grub_initrd_init (argc, argv, &initrd_ctx))
     goto fail;
 
-  size = grub_get_initrd_size (&initrd_ctx);
+  initrd_size = grub_get_initrd_size (&initrd_ctx);
+  grub_dprintf ("linux", "Loading initrd\n");
 
-  {
-    grub_relocator_chunk_t ch;
-    err = grub_relocator_alloc_chunk_align (relocator, &ch,
-					    0, (0xffffffff - size) + 1,
-					    size, 0x10000,
-					    GRUB_RELOCATOR_PREFERENCE_HIGH, 0);
+  if (is_bpi_boot == 0) {
+      grub_size_t initrd_pages;
+      initrd_pages = (GRUB_EFI_BYTES_TO_PAGES (initrd_size));
+      initrd_mem = allocate_initrd_mem (initrd_pages);
+  } else {
+      grub_err_t err;
+      initrd_mem = grub_linux_loongarch_alloc_virtual_mem_align (initrd_size, 0x10000, &err);
+      if (err)
+	goto fail;
+  }
 
-    if (err)
+  if (!initrd_mem)
+    {
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
       goto fail;
-    initrd_dest = get_virtual_current_address (ch);
-  }
+    }
 
-  if (grub_initrd_load (&initrd_ctx, argv, initrd_dest))
+  if (grub_initrd_load (&initrd_ctx, argv, initrd_mem))
     goto fail;
 
-  grub_snprintf ((char *) linux_args_addr + rd_addr_arg_off,
-		 sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"), "rd_start=0x%lx",
-		(grub_uint64_t) initrd_dest);
-  ((grub_uint64_t *) linux_args_addr)[linux_argc]
-    = (grub_uint64_t) ((grub_addr_t) linux_args_addr + rd_addr_arg_off);
-  linux_argc++;
-
-  grub_snprintf ((char *) linux_args_addr + rd_size_arg_off,
-		sizeof ("rd_size=0xXXXXXXXXXXXXXXXXX"), "rd_size=0x%lx",
-		(grub_uint64_t) size);
-  ((grub_uint64_t *) linux_args_addr)[linux_argc]
-    = (grub_uint64_t) ((grub_addr_t) linux_args_addr + rd_size_arg_off);
-  linux_argc++;
-
-
-  grub_snprintf ((char *) linux_args_addr + initrd_addr_arg_off,
-		 sizeof ("initrd=0xXXXXXXXXXXXXXXXX,0xXXXXXXXXXXXXXXXX"), "initrd=0x%lx,0x%lx",
-		((grub_uint64_t) initrd_dest & 0xffffffff), (grub_uint64_t) size);
-  ((grub_uint64_t *) linux_args_addr)[linux_argc]
-    = (grub_uint64_t) ((grub_addr_t) linux_args_addr + initrd_addr_arg_off);
-  linux_argc++;
-
-  initrd_loaded = 1;
-
- fail:
+  /* save ramdisk addr and size */
+  kernel_params.ramdisk_addr = (grub_addr_t) initrd_mem;
+  kernel_params.ramdisk_size = initrd_size;
+  grub_dprintf ("linux", "ramdisk [addr=%p, size=0x%lx]\n",
+		(void *) initrd_mem, initrd_size);
+fail:
   grub_initrd_close (&initrd_ctx);
-
+  if (is_bpi_boot == 0) {
+      if (initrd_mem && !kernel_params.ramdisk_addr)
+	grub_efi_free_pages ((grub_addr_t) initrd_mem,
+			     GRUB_EFI_BYTES_TO_PAGES (initrd_size));
+  }
   return grub_errno;
 }
 
@@ -656,9 +385,9 @@ static grub_command_t cmd_linux, cmd_initrd;
 GRUB_MOD_INIT(linux)
 {
   cmd_linux = grub_register_command ("linux", grub_cmd_linux,
-				     0, N_("Load Linux."));
+				     N_("FILE [ARGS...]"), N_("Load Linux."));
   cmd_initrd = grub_register_command ("initrd", grub_cmd_initrd,
-				      0, N_("Load initrd."));
+				      N_("FILE"), N_("Load initrd."));
   my_mod = mod;
 }
 
diff --git a/include/grub/efi/efi.h b/include/grub/efi/efi.h
index d24afba..262643a 100644
--- a/include/grub/efi/efi.h
+++ b/include/grub/efi/efi.h
@@ -129,13 +129,17 @@ extern void (*EXPORT_VAR(grub_efi_net_config)) (grub_efi_handle_t hnd,
 						char **device,
 						char **path);
 
-#if defined(__arm__) || defined(__aarch64__) || defined(__riscv)
+#if defined(__arm__) || defined(__aarch64__) || defined(__riscv) || defined(__loongarch__)
 void *EXPORT_FUNC(grub_efi_get_firmware_fdt)(void);
 grub_err_t EXPORT_FUNC(grub_efi_get_ram_base)(grub_addr_t *);
 #include <grub/cpu/linux.h>
 grub_err_t grub_arch_efi_linux_check_image(struct linux_arch_kernel_header *lh);
+#if defined(__loongarch__)
+grub_err_t grub_arch_efi_linux_boot_image(grub_addr_t addr, grub_size_t size, char *args);
+#else
 grub_err_t grub_arch_efi_linux_boot_image(grub_addr_t addr, char *args);
 #endif
+#endif
 
 grub_addr_t grub_efi_section_addr (const char *section);
 
diff --git a/include/grub/fdt.h b/include/grub/fdt.h
index 3514aa4..ba2f9a9 100644
--- a/include/grub/fdt.h
+++ b/include/grub/fdt.h
@@ -20,7 +20,7 @@
 #define GRUB_FDT_HEADER	1
 
 #if !defined(GRUB_MACHINE_EMU) && \
-    (defined(__arm__) || defined(__aarch64__) || defined(__riscv))
+    (defined(__arm__) || defined(__aarch64__) || defined(__riscv) || defined(__loongarch__))
 
 #include <grub/types.h>
 #include <grub/symbol.h>
@@ -148,6 +148,6 @@ int EXPORT_FUNC(grub_fdt_set_prop) (void *fdt, unsigned int nodeoffset, const ch
 })
 
 #endif /* !defined(GRUB_MACHINE_EMU) && \
-          (defined(__arm__) || defined(__aarch64__) || defined(__riscv)) */
+          (defined(__arm__) || defined(__aarch64__) || defined(__riscv) || defined(__loongarch__)) */
 
 #endif	/* ! GRUB_FDT_HEADER */
diff --git a/include/grub/loongarch64/asm.h b/include/grub/loongarch64/asm.h
deleted file mode 100644
index c3e77e9..0000000
--- a/include/grub/loongarch64/asm.h
+++ /dev/null
@@ -1,10 +0,0 @@
-#ifndef GRUB_LOONGARCH64_ASM_HEADER
-#define GRUB_LOONGARCH64_ASM_HEADER	1
-
-#define GRUB_ASM_T4 $a4
-#define GRUB_ASM_T5 $a5
-#define GRUB_ASM_SZREG 8
-#define GRUB_ASM_REG_S st.d
-#define GRUB_ASM_REG_L ld.d
-
-#endif
diff --git a/include/grub/loongarch64/efi/loongson.h b/include/grub/loongarch64/efi/loongson.h
deleted file mode 100644
index 6668d08..0000000
--- a/include/grub/loongarch64/efi/loongson.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2017  Free Software Foundation, Inc.
- *
- *  GRUB is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  GRUB is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef GRUB_EFI_LOONGSON_HEADER
-#define GRUB_EFI_LOONGSON_HEADER 1
-
-#include <grub/types.h>
-
-#include <grub/efi/api.h>
-
-#define GRUB_EFI_LOONGSON_BPI_TABLE_GUID	\
-  { 0x4660f721, 0x2ec5, 0x416a, \
-    { 0x89, 0x9a, 0x43, 0x18, 0x02, 0x50, 0xa0, 0xc9 } \
-  }
-
-#define GRUB_EFI_LOONGSON_MMAP_MAX 128
-typedef enum
-  {
-    GRUB_EFI_LOONGSON_SYSTEM_RAM = 1,
-    GRUB_EFI_LOONGSON_MEMORY_RESERVED,
-    GRUB_EFI_LOONGSON_ACPI_TABLE,
-    GRUB_EFI_LOONGSON_ACPI_NVS,
-    GRUB_EFI_LOONGSON_MAX_MEMORY_TYPE
-  }
-grub_efi_loongson_memory_type;
-
-typedef enum
-   {
-     GRUB_EFI_BPI_VER_NONE = 0,
-     GRUB_EFI_BPI_VER_V1 = 1000,
-     GRUB_EFI_BPI_VER_V2 = 1001,
-     GRUB_EFI_BPI_VER_V3 = 1002,
-   }
- grub_efi_loongson_bpi_version;
-
-#define ELF32_LOADMASK (0xf0000000UL)
-#define ELF64_LOADMASK (0xf000000000000000ULL)
-#define FLAGS_EFI_SUPPORT_BIT 0
-
-grub_uint8_t
-EXPORT_FUNC(grub_efi_loongson_calculatesum8) (const grub_uint8_t *Buffer,
-                                              grub_efi_uintn_t Length);
-
-grub_uint8_t
-EXPORT_FUNC(grub_efi_loongson_grub_calculatechecksum8) (const grub_uint8_t *Buffer,
-                                                       grub_efi_uintn_t Length);
-
-int EXPORT_FUNC(grub_efi_get_bpi_version) (const char *str);
-
-void *
-EXPORT_FUNC(grub_efi_loongson_get_boot_params) (void);
-
-typedef struct _extention_list_hdr {
-  grub_uint64_t  signature;
-  grub_uint32_t  length;
-  grub_uint8_t   revision;
-  grub_uint8_t   checksum;
-  union {
-    struct  _extention_list_hdr *next;
-    grub_uint64_t  next_offset;
-  };
-}GRUB_PACKED
-ext_list;
-
-typedef struct boot_params_interface {
-  grub_uint64_t signature; //{'B', 'P', 'I', 'x', 'x', 'x', 'x', 'x'}
-  grub_efi_system_table_t *systemtable;
-  union {
-    ext_list *extlist;
-    grub_uint64_t  extlist_offset;
-  };
-  grub_uint64_t  flags;
-}GRUB_PACKED
-boot_params_interface;
-
-typedef struct {
-  ext_list  header; //{MEM}
-  grub_uint8_t mapcount;
-  struct GRUB_PACKED memmap_v1 {
-    grub_uint32_t memtype;
-    grub_uint64_t memstart;
-    grub_uint64_t memsize;
-  } map[GRUB_EFI_LOONGSON_MMAP_MAX];
-}GRUB_PACKED
-mem_map_v1;
-
-typedef struct {
-  ext_list  header; //{MEM}
-  grub_uint8_t mapcount;
-  grub_uint32_t descver;
-  struct GRUB_PACKED memmap_v3 {
-    grub_uint32_t memtype;
-    grub_uint32_t pad;
-    grub_uint64_t memstart;
-    grub_uint64_t virtstart;
-    grub_uint64_t memsize;
-    grub_uint64_t attr;
-  } map[GRUB_EFI_LOONGSON_MMAP_MAX];
-}GRUB_PACKED
-mem_map_v3;
-
-typedef struct {
-  ext_list header; //{VBIOS}
-  grub_uint64_t  vbiosaddr;
-}GRUB_PACKED
-vbios;
-
-grub_uint32_t
-EXPORT_FUNC (grub_efi_loongson_memmap_v1_sort) (struct memmap_v1 array[],
-                                grub_uint32_t length, mem_map_v1 * mem,
-                                grub_uint32_t index, grub_uint32_t memtype);
-grub_uint32_t
-EXPORT_FUNC (grub_efi_loongson_memmap_v3_sort) (struct memmap_v3 array[],
-                                grub_uint32_t length, mem_map_v3 * mem,
-                                grub_uint32_t index, grub_uint32_t memtype);
-#endif /* ! GRUB_EFI_LOONGSON_HEADER */
diff --git a/include/grub/loongarch64/linux.h b/include/grub/loongarch64/linux.h
index cbf8775..af1f51d 100644
--- a/include/grub/loongarch64/linux.h
+++ b/include/grub/loongarch64/linux.h
@@ -1,6 +1,6 @@
 /*
  *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *  Copyright (C) 2021  Free Software Foundation, Inc.
  *
  *  GRUB is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -19,4 +19,126 @@
 #ifndef GRUB_LOONGARCH64_LINUX_HEADER
 #define GRUB_LOONGARCH64_LINUX_HEADER 1
 
+#include <grub/types.h>
+
+/* LoongArch linux kernel type */
+#define GRUB_LOONGARCH_LINUX_BAD 0
+#define GRUB_LOONGARCH_LINUX_ELF 1
+#define GRUB_LOONGARCH_LINUX_EFI 2
+
+#define GRUB_LOONGSON3_BOOT_MEM_MAP_MAX 128
+
+#define GRUB_LINUX_LOONGARCH_MAGIC_SIGNATURE  0x6E6F73676E6F6F4C /* 'Loongson' */
+#define linux_arch_kernel_header linux_loongarch64_kernel_header
+
+/* From linux/Documentation/loongarch/booting.txt
+ *
+ * 0-1: MZ
+ * 0x28: LoongArch\0
+ * 0x3c: PE/COFF头偏移
+ * 0x20e:内核版本号偏移-512
+ * riscv的version字段在0x20偏移处，现在LoongArch没有使用，是0
+ */
+struct linux_loongarch64_kernel_header
+{
+  grub_uint32_t code0;		/* Executable code */
+  grub_uint32_t code1;		/* Executable code */
+  grub_uint64_t text_offset;	/* Image load offset */
+  grub_uint64_t res0;		/* reserved */
+  grub_uint64_t res1;		/* reserved */
+  grub_uint64_t res2;		/* reserved */
+  grub_uint64_t magic;		/* Magic number, little endian, "Loongson" */
+  grub_uint64_t res3;		/* reserved */
+  grub_uint32_t res4;		/* reserved */
+  grub_uint32_t hdr_offset;	/* Offset of PE/COFF header */
+};
+
+struct linux_loongarch64_kernel_params
+{
+  grub_addr_t kernel_addr; 	/* kernel entry address */
+  grub_size_t kernel_size;	/* kernel size */
+  grub_addr_t ramdisk_addr;	/* initrd load address */
+  grub_size_t ramdisk_size;	/* initrd size */
+  int         linux_argc;	/* cmdline parameters number*/
+  grub_addr_t linux_argv;	/* cmdline parameters address*/
+  void*       linux_args;
+  void*       fdt;
+};
+
+#include <grub/efi/efi.h>
+#include <grub/elfload.h>
+
+#define GRUB_EFI_MAX_PHY_ADDRESS 0xffffffffffffULL
+#define ELF32_LOADMASK (0xf0000000UL)
+#define ELF64_LOADMASK (0xf000000000000000ULL)
+#define FLAGS_EFI_SUPPORT_BIT 0
+
+#define FDT_ADDR_CELLS_STRING "#address-cells"
+#define FDT_SIZE_CELLS_STRING "#size-cells"
+#define FDT_ADDR_SIZE_EXTRA ((2 * grub_fdt_prop_entry_size (sizeof(grub_uint32_t))) + \
+                             sizeof (FDT_ADDR_CELLS_STRING) + \
+                             sizeof (FDT_SIZE_CELLS_STRING))
+
+/* From arch/loongarch/include/asm/mach-loongson64/boot_param.h */
+struct _extention_list_hdr {
+    grub_uint64_t		signature;
+    grub_uint32_t  		length;
+    grub_uint8_t   		revision;
+    grub_uint8_t   		checksum;
+	union {
+      struct  _extention_list_hdr *next;
+      grub_uint64_t  next_offset;
+    };
+
+} GRUB_PACKED;
+
+struct boot_params_interface {
+    grub_uint64_t		signature;  /* {"B", "P", "I", "0", "1", ... } */
+    grub_efi_system_table_t *systemtable;
+    union {
+      struct _extention_list_hdr	*extlist;
+      grub_uint64_t  extlist_offset;
+    };
+    grub_uint64_t flags;
+}GRUB_PACKED;
+
+struct loongsonlist_mem_map {
+    struct _extention_list_hdr	header;	/* {"M", "E", "M"} */
+    grub_uint8_t  map_count;
+    struct memmap {
+	grub_uint32_t mem_type;
+	grub_uint64_t mem_start;
+	grub_uint64_t mem_size;
+    } GRUB_PACKED map[GRUB_LOONGSON3_BOOT_MEM_MAP_MAX];
+}GRUB_PACKED;
+
+grub_err_t
+finalize_efi_params_linux (struct linux_loongarch64_kernel_params *kernel_params);
+
+grub_err_t
+grub_linux_loongarch_elf_linux_boot_image (struct linux_loongarch64_kernel_params
+					   *kernel_params);
+
+void*
+grub_linux_loongarch_alloc_virtual_mem_addr (grub_addr_t addr,
+					     grub_size_t size,
+					     grub_err_t *err);
+
+void*
+grub_linux_loongarch_alloc_virtual_mem_align (grub_size_t size,
+					      grub_size_t align,
+					      grub_err_t *err);
+
+void
+grub_linux_loongarch_elf_relocator_unload (void);
+
+int
+grub_linux_loongarch_elf_get_boot_params (struct boot_params_interface **boot_params);
+
+grub_err_t
+grub_linux_loongarch_elf_boot_params (struct boot_params_interface *boot_params);
+
+grub_err_t
+grub_linux_loongarch_elf_load_kernel (grub_elf_t elf, const char *filename);
+
 #endif /* ! GRUB_LOONGARCH64_LINUX_HEADER */
-- 
2.20.1

